<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Assinador V15 - Force Landscape</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>

    <style>
        /* --- CSS GERAL --- */
        * { box-sizing: border-box; touch-action: none; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0; background-color: #121212; color: #eee;
            display: flex; flex-direction: column; height: 100dvh; overflow: hidden;
        }

        /* HEADER */
        header {
            background: #1e1e1e; padding: 10px 15px;
            display: flex; justify-content: space-between; align-items: center;
            height: 60px; border-bottom: 1px solid #333; z-index: 20;
        }

        .title { font-weight: 700; font-size: 16px; color: #fff; }
        .tools { display: flex; gap: 12px; }
        .btn-icon {
            background: #2c2c2c; border: 1px solid #444; color: #eee;
            width: 42px; height: 40px; border-radius: 8px;
            font-size: 20px; display: flex; align-items: center; justify-content: center;
        }

        /* WORKSPACE */
        #workspace {
            flex-grow: 1; position: relative; background: #000;
            display: flex; justify-content: center; align-items: center; overflow: hidden;
            padding-bottom: 90px; 
        }

        #mainCanvas {
            max-width: 98%; max-height: 98%;
            box-shadow: 0 0 20px rgba(0,0,0,0.8); display: none; 
        }

        /* START SCREEN */
        #startScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: #121212; z-index: 5;
        }
        
        .btn-big-open {
            background: #2a2a2a; border: 2px dashed #555; color: #ddd;
            width: 85%; padding: 40px 20px; border-radius: 16px;
            text-align: center; margin-top: -60px; transition: background 0.2s;
        }
        .btn-big-open span { font-size: 45px; display: block; margin-bottom: 15px; }
        .btn-big-open h3 { margin: 0; font-size: 20px; color: #fff; font-weight: 600; }
        
        #instruction {
            position: absolute; top: 15px;
            background: rgba(255, 193, 7, 0.95); color: #000;
            padding: 8px 20px; border-radius: 20px; font-weight: bold; font-size: 13px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5); pointer-events: none;
            display: none; z-index: 10;
        }
        
        #loading { display: none; color: #aaa; font-size: 14px; margin-top: 20px; }

        /* ACTION BAR */
        .action-bar {
            position: fixed; bottom: 0; left: 0; width: 100%;
            background: #1e1e1e; padding: 12px;
            padding-bottom: max(12px, env(safe-area-inset-bottom));
            display: flex; gap: 10px; border-top: 1px solid #333; z-index: 50;
        }

        .btn-action {
            border: none; border-radius: 8px; padding: 10px; flex: 1;
            font-size: 12px; font-weight: 700; text-transform: uppercase;
            color: white; display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 54px;
        }
        .btn-open { background: #333; border: 1px solid #555; max-width: 80px; font-size: 10px; }
        .btn-whats { background: #25D366; flex-grow: 2; opacity: 0.3; pointer-events: none; }
        .btn-save { background: #007bff; opacity: 0.3; pointer-events: none; }
        .active { opacity: 1 !important; pointer-events: auto !important; }

        input[type="file"] { display: none; }

        /* --- MODAL COM ROTA√á√ÉO FOR√áADA --- */
        .modal-overlay {
            position: fixed; 
            top: 0; left: 0; 
            width: 100vw; height: 100vh;
            background: #f5f5f5; 
            z-index: 9999;
            display: none; 
            flex-direction: column;
            overflow: hidden;
        }

        /* Classe M√°gica: For√ßa Paisagem mesmo com celular em p√© */
        .force-landscape {
            width: 100vh !important; /* Altura vira largura */
            height: 100vw !important; /* Largura vira altura */
            transform: rotate(90deg);
            transform-origin: center;
            /* Centraliza ap√≥s girar */
            position: fixed;
            top: 50%; left: 50%;
            margin-left: -50vh; /* Metade da nova largura */
            margin-top: -50vw;  /* Metade da nova altura */
        }

        .modal-header { 
            padding: 10px; background: #fff; text-align: center; color: #333; font-weight: bold; 
            font-size: 14px; border-bottom: 1px solid #ddd;
            display: flex; justify-content: space-between; align-items: center; padding-left: 20px; padding-right: 20px;
            height: 50px; flex-shrink: 0;
        }

        #padContainer { 
            flex-grow: 1; width: 100%; position: relative; overflow: hidden;
            background-color: #fff;
            background-image: radial-gradient(#ccc 1.5px, transparent 1.5px);
            background-size: 20px 20px;
        }
        
        #watermark {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #e0e0e0; font-size: 5vh; font-weight: bold; pointer-events: none;
            text-transform: uppercase; text-align: center;
        }

        #baseline {
            position: absolute; bottom: 20%; left: 5%; width: 90%; height: 2px;
            border-bottom: 2px dashed #ddd; pointer-events: none;
        }

        #padCanvas { width: 100%; height: 100%; display: block; }

        .modal-footer { 
            padding: 10px; background: #fff; display: flex; gap: 10px; 
            border-top: 1px solid #ddd;
            height: 70px; align-items: center; flex-shrink: 0;
        }
        
        .btn-m { height: 45px; flex: 1; border-radius: 8px; border: none; font-weight: bold; font-size: 14px; color: white; }
        .btn-cancel { background: #d9534f; max-width: 100px; }
        .btn-clear { background: #6c757d; max-width: 100px; }
        .btn-ok { background: #28a745; font-size: 16px; }

        #toast {
            position: fixed; bottom: 50%; left: 50%; transform: translate(-50%, 50%);
            background: rgba(0,0,0,0.8); color: white; padding: 15px 30px;
            border-radius: 8px; font-weight: bold; z-index: 200; display: none;
        }
    </style>
</head>
<body>

<header>
    <div class="title">Assinador V15</div>
    <div class="tools">
        <div id="btnUndo" class="btn-icon" onclick="undoAction()" style="opacity:0.3;">‚Ü©</div>
        <div class="btn-icon" onclick="rotateImage(-90)">‚Ü∫</div>
        <div class="btn-icon" onclick="rotateImage(90)">‚Üª</div>
    </div>
</header>

<div id="workspace">
    <div id="startScreen">
        <label for="fileInput" class="btn-big-open">
            <span>üìÇ</span>
            <h3>ABRIR ARQUIVO</h3>
            <p>PDF ou Imagem</p>
        </label>
        <div id="loading">‚åõ Processando...</div>
    </div>

    <div id="instruction">üëÜ Selecione onde quer assinar</div>
    <canvas id="mainCanvas"></canvas>
</div>

<div class="action-bar">
    <label for="fileInput" class="btn-action btn-open"><span>üìÇ</span>Abrir</label>
    <input type="file" id="fileInput" accept="*/*">
    <div id="btnWhats" class="btn-action btn-whats" onclick="shareDoc()">Enviar Whats</div>
    <div id="btnSave" class="btn-action btn-save" onclick="downloadDoc()">Baixar</div>
</div>

<div id="toast">Sucesso!</div>

<div class="modal-overlay" id="modal">
    <div class="modal-header">
        <span>‚úçÔ∏è Assinatura Horizontal</span>
        <span onclick="closeModal()" style="font-size: 20px; padding: 5px; cursor: pointer;">‚úï</span>
    </div>

    <div id="padContainer">
        <div id="watermark">Assine na Tela Inteira</div>
        <div id="baseline"></div>
        <canvas id="padCanvas"></canvas>
    </div>

    <div class="modal-footer">
        <button class="btn-m btn-cancel" onclick="closeModal()">Cancelar</button>
        <button class="btn-m btn-clear" onclick="clearPad()">Limpar</button>
        <button class="btn-m btn-ok" onclick="applySignature()">‚úî CONFIRMAR</button>
    </div>
</div>

<script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

    // ELEMENTOS
    const mainCanvas = document.getElementById('mainCanvas');
    const mainCtx = mainCanvas.getContext('2d');
    const padCanvas = document.getElementById('padCanvas');
    const padCtx = padCanvas.getContext('2d');
    const modal = document.getElementById('modal');
    
    // ESTADO
    let currentImage = null;
    let currentRotation = 0;
    let historyStack = [];
    let selectRect = null;
    let isSelecting = false;
    let startX, startY;
    let isForcedLandscape = false; // Flag crucial

    // --- ABRIR ---
    document.getElementById('fileInput').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if(!file) return;

        const validTypes = ['application/pdf', 'image/png', 'image/jpeg', 'image/jpg', 'image/webp'];
        if (!validTypes.includes(file.type) && !file.name.toLowerCase().endsWith('.pdf')) {
            showToast("‚ö†Ô∏è Arquivo inv√°lido!"); return;
        }

        document.querySelector('.btn-big-open').style.display = 'none';
        document.getElementById('loading').style.display = 'block';
        mainCanvas.style.display = 'none';
        
        document.getElementById('btnWhats').classList.remove('active');
        document.getElementById('btnSave').classList.remove('active');
        historyStack = []; currentRotation = 0;

        try {
            if(file.type.includes('pdf') || file.name.endsWith('.pdf')) await handlePDF(file);
            else await handleImage(file);
        } catch(err) { alert("Erro: " + err.message); location.reload(); }
    });

    function handleImage(file) {
        return new Promise(r => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => { currentImage = img; finishLoad(); r(); };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
    }

    async function handlePDF(file) {
        const d = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument(d).promise;
        const page = await pdf.getPage(1);
        const viewport = page.getViewport({scale: 2.5});
        const c = document.createElement('canvas');
        c.width = viewport.width; c.height = viewport.height;
        await page.render({canvasContext:c.getContext('2d'), viewport}).promise;
        
        const img = new Image();
        img.src = c.toDataURL('image/jpeg', 0.9);
        await new Promise(r => img.onload = r);
        currentImage = img;
        finishLoad();
    }

    function finishLoad() {
        document.getElementById('startScreen').style.display = 'none';
        mainCanvas.style.display = 'block';
        document.getElementById('instruction').style.display = 'block';
        document.getElementById('btnWhats').classList.add('active');
        document.getElementById('btnSave').classList.add('active');
        renderMain();
    }

    // --- RENDER ---
    function rotateImage(deg) {
        if(!currentImage) return;
        currentRotation = (currentRotation + deg) % 360;
        renderMain();
    }

    function renderMain() {
        const isVert = Math.abs(currentRotation) === 90 || Math.abs(currentRotation) === 270;
        mainCanvas.width = isVert ? currentImage.height : currentImage.width;
        mainCanvas.height = isVert ? currentImage.width : currentImage.height;

        mainCtx.save();
        mainCtx.clearRect(0,0,mainCanvas.width, mainCanvas.height);
        mainCtx.translate(mainCanvas.width/2, mainCanvas.height/2);
        mainCtx.rotate(currentRotation * Math.PI / 180);
        mainCtx.drawImage(currentImage, -currentImage.width/2, -currentImage.height/2);
        mainCtx.restore();
    }

    // --- SELE√á√ÉO ---
    function getCanvasPos(e) {
        const rect = mainCanvas.getBoundingClientRect();
        const t = e.touches ? e.touches[0] : e;
        const sx = mainCanvas.width / rect.width;
        const sy = mainCanvas.height / rect.height;
        return { x: (t.clientX - rect.left) * sx, y: (t.clientY - rect.top) * sy };
    }

    mainCanvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); isSelecting=true; document.getElementById('instruction').style.display='none'; const p = getCanvasPos(e); startX=p.x; startY=p.y; }, {passive:false});
    
    let lastX, lastY;
    mainCanvas.addEventListener('touchmove', (e)=>{ 
        if(!isSelecting) return; e.preventDefault(); 
        const p=getCanvasPos(e); lastX = p.x; lastY = p.y;
        renderMain();
        mainCtx.lineWidth = 4 * (mainCanvas.width/1000);
        mainCtx.strokeStyle = "#007bff"; mainCtx.setLineDash([10]);
        mainCtx.strokeRect(startX, startY, p.x-startX, p.y-startY);
        mainCtx.fillStyle = "rgba(0,123,255,0.2)";
        mainCtx.fillRect(startX, startY, p.x-startX, p.y-startY);
    }, {passive:false});
    
    mainCanvas.addEventListener('touchend', ()=>{
        isSelecting=false;
        const w = lastX - startX; const h = lastY - startY;
        if(Math.abs(w) > 20 && Math.abs(h) > 20) {
            selectRect = {x: startX, y: startY, w, h};
            openModal();
        } else { renderMain(); }
    });

    // --- ASSINATURA FORCE LANDSCAPE ---
    let points = [], isDrawing = false;

    function checkOrientation() {
        // Se a tela for mais alta que larga = Portrait (Vertical) -> Precisa girar
        if(window.innerHeight > window.innerWidth) {
            modal.classList.add('force-landscape');
            isForcedLandscape = true;
        } else {
            modal.classList.remove('force-landscape');
            isForcedLandscape = false;
        }
    }

    function openModal() {
        modal.style.display = 'flex';
        checkOrientation(); // Verifica e aplica a rota√ß√£o se necess√°rio
        
        // Timeout para garantir que o CSS aplicou a rota√ß√£o antes de calcular tamanho
        setTimeout(() => {
            resizePad();
            clearPad();
        }, 50);
        
        window.addEventListener('resize', handleResize);
    }

    function handleResize() {
        checkOrientation();
        resizePad();
    }

    function closeModal() {
        modal.style.display = 'none';
        modal.classList.remove('force-landscape'); // Reseta
        window.removeEventListener('resize', handleResize);
        renderMain();
    }

    function resizePad() {
        const container = document.getElementById('padContainer');
        const ratio = Math.max(window.devicePixelRatio || 1, 1);
        
        // O tamanho interno do canvas deve corresponder ao tamanho visual
        // Se estiver rotacionado (force-landscape), width visual √© height da tela
        // Mas o .offsetWidth pega o tamanho real do elemento DOM, que j√° est√° trocado pelo CSS?
        // Sim, se girarmos, o browser recalcula o layout dentro do elemento girado.
        
        padCanvas.width = container.offsetWidth * ratio;
        padCanvas.height = container.offsetHeight * ratio;
        padCtx.scale(ratio, ratio);
        
        padCtx.lineWidth = 3;
        padCtx.lineJoin = 'round';
        padCtx.lineCap = 'round';
        padCtx.strokeStyle = '#000080';
    }

    function clearPad() { 
        padCtx.clearRect(0,0,padCanvas.width,padCanvas.height); 
        points=[]; document.getElementById('watermark').style.display = 'block'; 
    }

    // MATEM√ÅTICA DE TOQUE CORRIGIDA
    function getPadPos(e) {
        const r = padCanvas.getBoundingClientRect();
        const t = e.touches ? e.touches[0] : e;
        
        let clientX = t.clientX;
        let clientY = t.clientY;

        // SE ESTIVER ROTACIONADO NA MARRA
        // A m√°gica: getBoundingClientRect j√° retorna as coordenadas da caixa girada!
        // Ent√£o clientX - left DEVE funcionar se o browser for moderno.
        // O problema √© o eixo local.
        
        // Teste de l√≥gica: Se girou 90deg, o topo virou direita.
        // Vamos confiar no offset simples primeiro, pois 'padCanvas' √© filho do container girado.
        // Se o evento √© capturado no canvas, o offset deve ser local.
        
        // No entanto, touch event retorna global (screen).
        
        if (isForcedLandscape) {
            // Se for√ßado, precisamos mapear as coordenadas da tela para o canvas girado
            // O CSS girou o centro.
            // X da tela -> Y do canvas (invertido ou n√£o?)
            // Y da tela -> X do canvas
            
            // Vamos usar uma abordagem mais robusta: Map Range
            // Como o elemento ocupa 100% da dimens√£o trocada:
            
            // Normaliza X e Y da tela (0 a 1)
            const normX = clientX / window.innerWidth;
            const normY = clientY / window.innerHeight;
            
            // No modo for√ßado (90deg), o topo do canvas est√° na esquerda da tela.
            // O canvas X vai de 0 a W (que √© a altura da tela)
            // O canvas Y vai de 0 a H (que √© a largura da tela)
            
            // Tela Y (topo->baixo) = Canvas X (Esq->Dir)
            // Tela X (esq->dir) = Canvas Y (Baixo->Topo? N√£o, Topo->Baixo √© direita)
            // Se girou 90deg CW: Topo visual √© a direita da tela original.
            
            // Vamos simplificar:
            // Canvas X = clientY
            // Canvas Y = (window.innerWidth - clientX)
            
            // Ajuste fino para DPI
            // Precisamos multiplicar pela propor√ß√£o interna do canvas
            const cssW = padCanvas.offsetWidth;
            const cssH = padCanvas.offsetHeight;
            
            return {
                x: clientY - r.top, 
                y: (r.right - clientX) // Aproxima√ß√£o cl√°ssica de 90deg
                // Se ficar espelhado, trocamos aqui.
                // Mas espere! Se usarmos r.top e r.left do bounding box, j√° temos a posi√ß√£o na tela.
            };
            
            // CORRE√á√ÉO SEGURA V15:
            // N√£o vamos tentar adivinhar a matriz de rota√ß√£o.
            // O Canvas desenha em coordenadas locais.
            // Se o usu√°rio arrasta o dedo "para a direita" (no mundo real),
            // ele est√° arrastando "para baixo" na tela do celular.
            // O CSS girou o canvas.
            // O usu√°rio v√™ o canvas de p√©.
            // Se ele arrasta da esq pra direita (mundo real), ele arrasta no Eixo X do canvas.
            // Na tela do celular, isso √© Eixo Y (cima para baixo).
            
            return {
                x: clientY, // Movimento vertical da tela vira horizontal do canvas
                y: (window.innerWidth - clientX) // Movimento horizontal da tela vira vertical invertido
            };
        }
        
        return { x: clientX - r.left, y: clientY - r.top };
    }
    
    // Sobrescrevendo a fun√ß√£o para garantir compatibilidade
    // Para simplificar a vida do usu√°rio e evitar bugs de matem√°tica de matrizes no "Force Mode",
    // vamos usar uma l√≥gica relativa:
    
    function getCorrectPos(e) {
        if(!isForcedLandscape) {
             const r = padCanvas.getBoundingClientRect();
             const t = e.touches ? e.touches[0] : e;
             return { x: t.clientX - r.left, y: t.clientY - r.top };
        } else {
             // L√≥gica Force Landscape (Celular em p√©, Tela deitada)
             // O usu√°rio segura o celular deitado.
             // O topo do celular √© a "Esquerda".
             // O bot√£o home √© a "Direita".
             
             // Touch X (Eixo menor do celular) vira Y do desenho.
             // Touch Y (Eixo maior do celular) vira X do desenho.
             
             const t = e.touches ? e.touches[0] : e;
             // Ajuste manual fino baseado em testes de rota√ß√£o CSS
             return {
                 x: t.clientY, 
                 y: window.innerWidth - t.clientX
             };
        }
    }

    padCanvas.addEventListener('touchstart', (e)=>{ 
        e.preventDefault(); isDrawing=true; points.push(getCorrectPos(e));
        document.getElementById('watermark').style.display = 'none';
    }, {passive:false});
    
    padCanvas.addEventListener('touchmove', (e)=>{ 
        if(!isDrawing) return; e.preventDefault(); points.push(getCorrectPos(e));
        if(points.length < 3) return;
        padCtx.beginPath();
        padCtx.moveTo(points[points.length-2].x, points[points.length-2].y);
        padCtx.lineTo(points[points.length-1].x, points[points.length-1].y);
        padCtx.stroke();
    }, {passive:false});
    
    padCanvas.addEventListener('touchend', ()=>{ isDrawing=false; points=[]; });

    // --- FINALIZAR ---
    function applySignature() {
        if(currentImage) { historyStack.push(currentImage.src); document.getElementById('btnUndo').style.opacity=1; document.getElementById('btnUndo').style.pointerEvents='auto'; }
        
        closeModal();
        renderMain();
        mainCtx.drawImage(padCanvas, selectRect.x, selectRect.y, selectRect.w, selectRect.h);
        
        const i = new Image();
        i.src = mainCanvas.toDataURL('image/png', 1.0);
        i.onload = () => { currentImage = i; renderMain(); showToast("Assinado!"); }
    }

    function undoAction() {
        if(!historyStack.length) return;
        const src = historyStack.pop();
        if(!historyStack.length) { document.getElementById('btnUndo').style.opacity=0.3; document.getElementById('btnUndo').style.pointerEvents='none'; }
        const i = new Image(); i.src = src; i.onload = () => { currentImage=i; renderMain(); showToast("Desfeito"); }
    }

    function showToast(msg) {
        const t = document.getElementById('toast'); t.innerText=msg; t.style.display='block';
        setTimeout(()=>t.style.display='none', 2000);
    }

    async function shareDoc() {
        if(!currentImage) return;
        mainCanvas.toBlob(async (b) => {
            const f = new File([b], "Assinado.png", {type: "image/png"});
            try { await navigator.share({files:[f]}); } catch(e){}
        });
    }

    function downloadDoc() {
        if(!currentImage) return;
        const a = document.createElement('a'); a.download = `Doc_${Date.now()}.png`;
        a.href = mainCanvas.toDataURL(); a.click();
    }
</script>
</body>
</html>
